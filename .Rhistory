dummy[,bin:=cut(sim, p.breaks, labels=probs$labels)] #finds the relevant bin labels
dummy <- dummy[is.na(bin)==FALSE, j=list(count=sum(weight)), by=list(rep.no,bin,bin.no)] #sums weights by bin and rep number
dummy[order(rep.no, bin.no)]
}
dummy.simulate(y)
dummy.simulate <- function(weight, probs=1, breaks=NULL, filter=NULL, start.date=0, end.date=2000, bin.width=100, reps=100) {
require(data.table)
if(is.null(breaks)==TRUE) {breaks <<- seq(start.date, end.date, bin.width)} #if breaks not specified, sets them based on other arguments
labels <- numeric(length(breaks))-1
for(i in 1:length(labels)) {
labels[i] <- paste(breaks[i], breaks[i+1], sep="-") #sets bin labels based on breaks
}
probs <- data.table(cbind(probs, labels)) #append labels to relative probs, recycling the latter if necessary
if(is.vector(weight)==1 & length(weight)==1) {weight <- rep(1, weight)} #if weight is a single value, use as number of entities
dummy <- data.table(weight) #convert weights to data table format, if necessary.
if(length(filter)>0 & "group"%in%colnames(dummy)) {dummy <- dummy[group==filter,]} #filter if appropriate
rep.no <- rep(1:reps, each=nrow(dummy))
dummy <- cbind(rep.no, dummy) #recycles input data 'reps' times to provide frame for simulation
p.sum <- sum(probs$probs) #'stacks up' all the relative probabilities
p.breaks <- c(0, cumsum(probs$probs)) #uses cumulative sum of relative probabilities to set breaks
dummy[,sim:=runif(nrow(dummy), 0, p.sum)] #samples from within p.sum
dummy[,bin.no:=cut(sim,breaks, labels=FALSE)] #records the relevant bin for each simulated date
dummy[,bin:=cut(sim, p.breaks, labels=probs$labels)] #finds the relevant bin labels
dummy <- dummy[is.na(bin)==FALSE, j=list(count=sum(weight)), by=list(rep.no,bin,bin.no)] #sums weights by bin and rep number
dummy[order(rep.no, bin.no)]
}
dummy.simulate(y)
probs=1
breaks=NULL
filter=NULL
start.date=0
end.date=2000
bin.width=100
reps=100
require(data.table)
if(is.vector(weight)==1 & length(weight)==1) {weight <- rep(1, weight)} #if weight is a single value, use as number of entities
weight <- 1:10
if(is.vector(weight)==1 & length(weight)==1) {weight <- rep(1, weight)} #if weight is a single value, use as number of entities
weight=10
if(is.vector(weight)==1 & length(weight)==1) {weight <- rep(1, weight)} #if weight is a single value, use as number of entities
dummy <- data.table(weight) #convert weights to data table format, if necessary.
if(length(filter)>0 & "group"%in%colnames(dummy)) {dummy <- dummy[group==filter,]} #filter if appropriate
if(is.null(breaks)==TRUE) {breaks <<- seq(start.date, end.date, bin.width)} #if breaks not specified, sets them based on other arguments
labels <- numeric(length(breaks))-1
for(i in 1:length(labels)) {
labels[i] <- paste(breaks[i], breaks[i+1], sep="-") #sets bin labels based on breaks
}
labels <- numeric((length(breaks))-1)
for(i in 1:length(labels)) {
labels[i] <- paste(breaks[i], breaks[i+1], sep="-") #sets bin labels based on breaks
}
probs <- data.table(cbind(probs, labels)) #append labels to relative probs, recycling the latter if necessary
View(probs)
rep.no <- rep(1:reps, each=nrow(dummy))
dummy <- cbind(rep.no, dummy) #recycles input data 'reps' times to provide frame for simulation
View(dummy)
p.sum <- sum(probs$probs) #'stacks up' all the relative probabilities
View(probs)
class(probs$probs)
View(probs)
z <- as.numeric(probs$probs)
z
p.sum <- sum(as.numeric(probs$probs)) #'stacks up' all the relative probabilities
p.breaks <- c(0, cumsum(as.numeric(probs$probs))) #uses cumulative sum of relative probabilities to set breaks
dummy[,sim:=runif(nrow(dummy), 0, p.sum)] #samples from within p.sum
View(dummy)
dummy[,bin.no:=cut(sim,breaks, labels=FALSE)] #records the relevant bin for each simulated date
View(dummy)
dummy[,bin.no:=cut(sim, p.breaks, labels=FALSE)] #records the relevant bin for each simulated date
View(dummy)
dummy[,bin:=cut(sim, p.breaks, labels=probs$labels)] #finds the relevant bin labels
View(dummy)
dummy <- dummy[is.na(bin)==FALSE, j=list(count=sum(weight)), by=list(rep.no,bin,bin.no)] #sums weights by bin and rep number
View(dummy)
dummy[order(rep.no, bin.no)]
dummy.simulate <- function(weight, probs=1, breaks=NULL, filter=NULL, start.date=0, end.date=2000, bin.width=100, reps=100) {
require(data.table)
if(is.vector(weight)==1 & length(weight)==1) {weight <- rep(1, weight)} #if weight is a single value, use as number of entities
dummy <- data.table(weight) #convert weights to data table format, if necessary.
if(length(filter)>0 & "group"%in%colnames(dummy)) {dummy <- dummy[group==filter,]} #filter if appropriate
if(is.null(breaks)==TRUE) {breaks <<- seq(start.date, end.date, bin.width)} #if breaks not specified, sets them based on other arguments
labels <- numeric((length(breaks))-1)
for(i in 1:length(labels)) {
labels[i] <- paste(breaks[i], breaks[i+1], sep="-") #sets bin labels based on breaks
}
probs <- data.table(cbind(probs, labels)) #append labels to relative probs, recycling the latter if necessary
rep.no <- rep(1:reps, each=nrow(dummy))
dummy <- cbind(rep.no, dummy) #recycles input data 'reps' times to provide frame for simulation
p.sum <- sum(as.numeric(probs$probs)) #'stacks up' all the relative probabilities
p.breaks <- c(0, cumsum(as.numeric(probs$probs))) #uses cumulative sum of relative probabilities to set breaks
dummy[,sim:=runif(nrow(dummy), 0, p.sum)] #samples from within p.sum
dummy[,bin.no:=cut(sim, p.breaks, labels=FALSE)] #records the relevant bin for each simulated date
dummy[,bin:=cut(sim, p.breaks, labels=probs$labels)] #finds the relevant bin labels
dummy <- dummy[is.na(bin)==FALSE, j=list(count=sum(weight)), by=list(rep.no,bin,bin.no)] #sums weights by bin and rep number
dummy[order(rep.no, bin.no)]
}
dummy_simulate(y)
dummy.simulate(y)
y <- 1:5
dummy.simulate(y)
?numeric
labels <- numeric(length=length(breaks)-1)
dummy.simulate <- function(weight, probs=1, breaks=NULL, filter=NULL, start.date=0, end.date=2000, bin.width=100, reps=100) {
require(data.table)
if(is.vector(weight)==1 & length(weight)==1) {weight <- rep(1, weight)} #if weight is a single value, use as number of entities
dummy <- data.table(weight) #convert weights to data table format, if necessary.
if(length(filter)>0 & "group"%in%colnames(dummy)) {dummy <- dummy[group==filter,]} #filter if appropriate
if(is.null(breaks)==TRUE) {breaks <<- seq(start.date, end.date, bin.width)} #if breaks not specified, sets them based on other arguments
labels <- numeric(length=length(breaks)-1)
for(i in 1:length(labels)) {
labels[i] <- paste(breaks[i], breaks[i+1], sep="-") #sets bin labels based on breaks
}
probs <- data.table(cbind(probs, labels)) #append labels to relative probs, recycling the latter if necessary
rep.no <- rep(1:reps, each=nrow(dummy))
dummy <- cbind(rep.no, dummy) #recycles input data 'reps' times to provide frame for simulation
p.sum <- sum(as.numeric(probs$probs)) #'stacks up' all the relative probabilities
p.breaks <- c(0, cumsum(as.numeric(probs$probs))) #uses cumulative sum of relative probabilities to set breaks
dummy[,sim:=runif(nrow(dummy), 0, p.sum)] #samples from within p.sum
dummy[,bin.no:=cut(sim, p.breaks, labels=FALSE)] #records the relevant bin for each simulated date
dummy[,bin:=cut(sim, p.breaks, labels=probs$labels)] #finds the relevant bin labels
dummy <- dummy[is.na(bin)==FALSE, j=list(count=sum(weight)), by=list(rep.no,bin,bin.no)] #sums weights by bin and rep number
dummy[order(rep.no, bin.no)]
}
dummy.simulate(y)
dummy.simulate <- function(weight, probs=1, breaks=NULL, filter=NULL, start.date=0, end.date=2000, bin.width=100, reps=100) {
require(data.table)
if(is.vector(weight)==1 & length(weight)==1) {weight <- rep(1, weight)} #if weight is a single value, use as number of entities
dummy <- data.table(weight) #convert weights to data table format, if necessary.
if(length(filter)>0 & "group"%in%colnames(dummy)) {dummy <- dummy[group==filter,]} #filter if appropriate
if(is.null(breaks)==TRUE) {breaks <<- seq(start.date, end.date, bin.width)} #if breaks not specified, sets them based on other arguments
x <- length(breaks)-1
labels <- numeric(length=length(breaks)-1)
for(i in 1:length(labels)) {
labels[i] <- paste(breaks[i], breaks[i+1], sep="-") #sets bin labels based on breaks
}
probs <- data.table(cbind(probs, labels)) #append labels to relative probs, recycling the latter if necessary
rep.no <- rep(1:reps, each=nrow(dummy))
dummy <- cbind(rep.no, dummy) #recycles input data 'reps' times to provide frame for simulation
p.sum <- sum(as.numeric(probs$probs)) #'stacks up' all the relative probabilities
p.breaks <- c(0, cumsum(as.numeric(probs$probs))) #uses cumulative sum of relative probabilities to set breaks
dummy[,sim:=runif(nrow(dummy), 0, p.sum)] #samples from within p.sum
dummy[,bin.no:=cut(sim, p.breaks, labels=FALSE)] #records the relevant bin for each simulated date
dummy[,bin:=cut(sim, p.breaks, labels=probs$labels)] #finds the relevant bin labels
dummy <- dummy[is.na(bin)==FALSE, j=list(count=sum(weight)), by=list(rep.no,bin,bin.no)] #sums weights by bin and rep number
dummy[order(rep.no, bin.no)]
}
dummy.simulate(y)
dummy.simulate <- function(weight, probs=1, breaks=NULL, filter=NULL, start.date=0, end.date=2000, bin.width=100, reps=100) {
require(data.table)
if(is.vector(weight)==1 & length(weight)==1) {weight <- rep(1, weight)} #if weight is a single value, use as number of entities
dummy <- data.table(weight) #convert weights to data table format, if necessary.
if(length(filter)>0 & "group"%in%colnames(dummy)) {dummy <- dummy[group==filter,]} #filter if appropriate
if(is.null(breaks)==TRUE) {breaks <<- seq(start.date, end.date, bin.width)} #if breaks not specified, sets them based on other arguments
x <- length(breaks)-1
labels <- numeric(x)
for(i in 1:length(labels)) {
labels[i] <- paste(breaks[i], breaks[i+1], sep="-") #sets bin labels based on breaks
}
probs <- data.table(cbind(probs, labels)) #append labels to relative probs, recycling the latter if necessary
rep.no <- rep(1:reps, each=nrow(dummy))
dummy <- cbind(rep.no, dummy) #recycles input data 'reps' times to provide frame for simulation
p.sum <- sum(as.numeric(probs$probs)) #'stacks up' all the relative probabilities
p.breaks <- c(0, cumsum(as.numeric(probs$probs))) #uses cumulative sum of relative probabilities to set breaks
dummy[,sim:=runif(nrow(dummy), 0, p.sum)] #samples from within p.sum
dummy[,bin.no:=cut(sim, p.breaks, labels=FALSE)] #records the relevant bin for each simulated date
dummy[,bin:=cut(sim, p.breaks, labels=probs$labels)] #finds the relevant bin labels
dummy <- dummy[is.na(bin)==FALSE, j=list(count=sum(weight)), by=list(rep.no,bin,bin.no)] #sums weights by bin and rep number
dummy[order(rep.no, bin.no)]
}
dummy.simulate(y)
dummy.simulate <- function(weight, probs=1, breaks=NULL, filter=NULL, start.date=0, end.date=2000, bin.width=100, reps=100) {
require(data.table)
if(is.vector(weight)==1 & length(weight)==1) {weight <- rep(1, weight)} #if weight is a single value, use as number of entities
dummy <- data.table(weight) #convert weights to data table format, if necessary.
if(length(filter)>0 & "group"%in%colnames(dummy)) {dummy <- dummy[group==filter,]} #filter if appropriate
if(is.null(breaks)==TRUE) {breaks <<- seq(start.date, end.date, bin.width)} #if breaks not specified, sets them based on other arguments
x <- length(breaks)-1
labels <- numeric(length=x)
for(i in 1:length(labels)) {
labels[i] <- paste(breaks[i], breaks[i+1], sep="-") #sets bin labels based on breaks
}
probs <- data.table(cbind(probs, labels)) #append labels to relative probs, recycling the latter if necessary
rep.no <- rep(1:reps, each=nrow(dummy))
dummy <- cbind(rep.no, dummy) #recycles input data 'reps' times to provide frame for simulation
p.sum <- sum(as.numeric(probs$probs)) #'stacks up' all the relative probabilities
p.breaks <- c(0, cumsum(as.numeric(probs$probs))) #uses cumulative sum of relative probabilities to set breaks
dummy[,sim:=runif(nrow(dummy), 0, p.sum)] #samples from within p.sum
dummy[,bin.no:=cut(sim, p.breaks, labels=FALSE)] #records the relevant bin for each simulated date
dummy[,bin:=cut(sim, p.breaks, labels=probs$labels)] #finds the relevant bin labels
dummy <- dummy[is.na(bin)==FALSE, j=list(count=sum(weight)), by=list(rep.no,bin,bin.no)] #sums weights by bin and rep number
dummy[order(rep.no, bin.no)]
}
dummy.simulate(y)
labels <- numeric((length(breaks)-1))
dummy.simulate <- function(weight, probs=1, breaks=NULL, filter=NULL, start.date=0, end.date=2000, bin.width=100, reps=100) {
require(data.table)
if(is.vector(weight)==1 & length(weight)==1) {weight <- rep(1, weight)} #if weight is a single value, use as number of entities
dummy <- data.table(weight) #convert weights to data table format, if necessary.
if(length(filter)>0 & "group"%in%colnames(dummy)) {dummy <- dummy[group==filter,]} #filter if appropriate
if(is.null(breaks)==TRUE) {breaks <<- seq(start.date, end.date, bin.width)} #if breaks not specified, sets them based on other arguments
labels <- numeric((length(breaks)-1))
for(i in 1:length(labels)) {
labels[i] <- paste(breaks[i], breaks[i+1], sep="-") #sets bin labels based on breaks
}
probs <- data.table(cbind(probs, labels)) #append labels to relative probs, recycling the latter if necessary
rep.no <- rep(1:reps, each=nrow(dummy))
dummy <- cbind(rep.no, dummy) #recycles input data 'reps' times to provide frame for simulation
p.sum <- sum(as.numeric(probs$probs)) #'stacks up' all the relative probabilities
p.breaks <- c(0, cumsum(as.numeric(probs$probs))) #uses cumulative sum of relative probabilities to set breaks
dummy[,sim:=runif(nrow(dummy), 0, p.sum)] #samples from within p.sum
dummy[,bin.no:=cut(sim, p.breaks, labels=FALSE)] #records the relevant bin for each simulated date
dummy[,bin:=cut(sim, p.breaks, labels=probs$labels)] #finds the relevant bin labels
dummy <- dummy[is.na(bin)==FALSE, j=list(count=sum(weight)), by=list(rep.no,bin,bin.no)] #sums weights by bin and rep number
dummy[order(rep.no, bin.no)]
}
labels <- numeric((length(breaks)-1))
dummy.simulate(y)
breaks=NULL
if(is.null(breaks)==TRUE) {breaks <<- seq(start.date, end.date, bin.width)} #if breaks not specified, sets them based on other arguments
numeric((length(breaks)-1))
labels=NULL
for(i in 1:(length(breask)-1)) {
labels[i] <- paste(breaks[i], breaks[i+1], sep="-") #sets bin labels based on breaks
}
for(i in 1:(length(breaks)-1)) {
labels[i] <- paste(breaks[i], breaks[i+1], sep="-") #sets bin labels based on breaks
}
dummy.simulate <- function(weight, probs=1, breaks=NULL, filter=NULL, start.date=0, end.date=2000, bin.width=100, reps=100) {
require(data.table)
if(is.vector(weight)==1 & length(weight)==1) {weight <- rep(1, weight)} #if weight is a single value, use as number of entities
dummy <- data.table(weight) #convert weights to data table format, if necessary.
if(length(filter)>0 & "group"%in%colnames(dummy)) {dummy <- dummy[group==filter,]} #filter if appropriate
if(is.null(breaks)==TRUE) {breaks <<- seq(start.date, end.date, bin.width)} #if breaks not specified, sets them based on other arguments
for(i in 1:(length(breaks)-1)) {
labels[i] <- paste(breaks[i], breaks[i+1], sep="-") #sets bin labels based on breaks
}
probs <- data.table(cbind(probs, labels)) #append labels to relative probs, recycling the latter if necessary
rep.no <- rep(1:reps, each=nrow(dummy))
dummy <- cbind(rep.no, dummy) #recycles input data 'reps' times to provide frame for simulation
p.sum <- sum(as.numeric(probs$probs)) #'stacks up' all the relative probabilities
p.breaks <- c(0, cumsum(as.numeric(probs$probs))) #uses cumulative sum of relative probabilities to set breaks
dummy[,sim:=runif(nrow(dummy), 0, p.sum)] #samples from within p.sum
dummy[,bin.no:=cut(sim, p.breaks, labels=FALSE)] #records the relevant bin for each simulated date
dummy[,bin:=cut(sim, p.breaks, labels=probs$labels)] #finds the relevant bin labels
dummy <- dummy[is.na(bin)==FALSE, j=list(count=sum(weight)), by=list(rep.no,bin,bin.no)] #sums weights by bin and rep number
dummy[order(rep.no, bin.no)]
}
dummy.simulate(y)
dummy.simulate <- function(weight, probs=1, breaks=NULL, filter=NULL, start.date=0, end.date=2000, bin.width=100, reps=100) {
require(data.table)
if(is.vector(weight)==1 & length(weight)==1) {weight <- rep(1, weight)} #if weight is a single value, use as number of entities
dummy <- data.table(weight) #convert weights to data table format, if necessary.
if(length(filter)>0 & "group"%in%colnames(dummy)) {dummy <- dummy[group==filter,]} #filter if appropriate
if(is.null(breaks)==TRUE) {breaks <- seq(start.date, end.date, bin.width)} #if breaks not specified, sets them based on other arguments
for(i in 1:(length(breaks)-1)) {
labels[i] <- paste(breaks[i], breaks[i+1], sep="-") #sets bin labels based on breaks
}
probs <- data.table(cbind(probs, labels)) #append labels to relative probs, recycling the latter if necessary
rep.no <- rep(1:reps, each=nrow(dummy))
dummy <- cbind(rep.no, dummy) #recycles input data 'reps' times to provide frame for simulation
p.sum <- sum(as.numeric(probs$probs)) #'stacks up' all the relative probabilities
p.breaks <- c(0, cumsum(as.numeric(probs$probs))) #uses cumulative sum of relative probabilities to set breaks
dummy[,sim:=runif(nrow(dummy), 0, p.sum)] #samples from within p.sum
dummy[,bin.no:=cut(sim, p.breaks, labels=FALSE)] #records the relevant bin for each simulated date
dummy[,bin:=cut(sim, p.breaks, labels=probs$labels)] #finds the relevant bin labels
dummy <- dummy[is.na(bin)==FALSE, j=list(count=sum(weight)), by=list(rep.no,bin,bin.no)] #sums weights by bin and rep number
dummy[order(rep.no, bin.no)]
}
dummy.simulate(y)
dummy.simulate <- function(weight, probs=1, breaks=NULL, filter=NULL, start.date=0, end.date=2000, bin.width=100, reps=100) {
require(data.table)
if(is.vector(weight)==1 & length(weight)==1) {weight <- rep(1, weight)} #if weight is a single value, use as number of entities
dummy <- data.table(weight) #convert weights to data table format, if necessary.
if(length(filter)>0 & "group"%in%colnames(dummy)) {dummy <- dummy[group==filter,]} #filter if appropriate
if(is.null(breaks)==TRUE) {breaks <- seq(start.date, end.date, bin.width)} #if breaks not specified, sets them based on other arguments
for(i in 1:(length(breaks)-1)) {
labels[i] <- paste(breaks[i], breaks[i+1], sep="-") #sets bin labels based on breaks
}
probs <- data.table(cbind(probs, labels)) #append labels to relative probs, recycling the latter if necessary
rep.no <- rep(1:reps, each=nrow(dummy))
dummy <- cbind(rep.no, dummy) #recycles input data 'reps' times to provide frame for simulation
p.sum <- sum(as.numeric(probs$probs)) #'stacks up' all the relative probabilities
p.breaks <- c(0, cumsum(as.numeric(probs$probs))) #uses cumulative sum of relative probabilities to set breaks
dummy[,sim:=runif(nrow(dummy), 0, p.sum)] #samples from within p.sum
dummy[,bin.no:=cut(sim, p.breaks, labels=FALSE)] #records the relevant bin for each simulated date
dummy[,bin:=cut(sim, p.breaks, labels=probs$labels)] #finds the relevant bin labels
dummy <- dummy[is.na(bin)==FALSE, j=list(count=sum(weight)), by=list(rep.no,bin,bin.no)] #sums weights by bin and rep number
dummy[order(rep.no, bin.no)]
}
dummy.simulate(y)
a <- dummy.simulate(y)
View(a)
date.simulate <- function(data, filter=NULL, start.date=0, end.date=2000, bin.width=100, reps=100, weight=1) {
require(data.table)
data <- cbind(data, weight) #appends weights to list of date ranges, recycling if necessary (e.g. for uniform weight)
if(length(filter)>0 & "group" %in% colnames(data)) {data <- data[group%in%filter,]} #filters data, if appropriate
data <- data[End >= start.date & Start <= end.date] #excludes ranges that fall entirely outside the study period
breaks <<- seq(start.date, end.date, bin.width) #sets breaks and saves them externally
for(i in 1:(length(breaks)-1)) {
labels[i] <- paste(breaks[i], breaks[i+1], sep="-") #sets bin labels
}
params <<- paste("_", start.date, "-", end.date, "_by_", bin.width, "_x", reps, sep="") #saves char value with key parameters
rep.no <- rep(1:reps, each=nrow(data))
data <- cbind(rep.no, data) #recycles input data 'reps' times to provide frame for simulation
data[,sim:={x<-runif(nrow(data)); (x*(data[,End]-data[,Start]))+data[,Start]}] #simulates a date for each row
data[,bin.no:=cut(sim,breaks, labels=FALSE)] #records the relevant bin for each simulated date
data[,bin:=cut(sim,breaks,labels=labels)] #records the relevant bin labels
data <- data[is.na(bin)==FALSE, j=list(count=sum(weight)), by=list(rep.no,bin,bin.no)] #sums weights by bin and rep number
data[order(rep.no, bin.no)]
}
dummy.simulate(y)
b <- date.simulate(y)
y <- data.table(1:4)
dummy.simulate(y)
b <- dummy.simulate(y)
b <- dummy.simulate(y)
b <- dummy.simulate(y)
b <- dummy.simulate(y)
b <- dummy.simulate(y)
y <- 1:4
b <- dummy.simulate(y)
b <- dummy.simulate(y)
b <- dummy.simulate(y)
b <- dummy.simulate(y)
b <- dummy.simulate(y)
b <- dummy.simulate(y)
b <- dummy.simulate(y)
y <- rep(1,10)
b <- dummy.simulate(y)
b <- dummy.simulate(y)
b <- dummy.simulate(y)
b <- dummy.simulate(y)
b <- dummy.simulate(y)
y <- data.table(rep(1,10))
View(y)
b <- dummy.simulate(y)
b <- dummy.simulate(y)
b <- dummy.simulate(y)
b <- dummy.simulate(y)
b <- dummy.simulate(y)
b <- dummy.simulate(y)
y <- 10
b <- dummy.simulate(y)
b <- dummy.simulate(y)
b <- dummy.simulate(y)
b <- dummy.simulate(y)
b <- dummy.simulate(y)
y <- data.table(10)
b <- dummy.simulate(y)
b <- dummy.simulate(y)
b <- dummy.simulate(y)
b <- dummy.simulate(y)
b <- dummy.simulate(y)
b <- dummy.simulate(y)
View(b)
y <- 10
b <- dummy.simulate(y)
View(b)
data.table(cbind(1:10, "a"))
y <- data.table(cbind(1:10, "a"))
b <- dummy.simulate(y)
weight <- y
if(is.vector(weight)==1 & length(weight)==1) {weight <- rep(1, weight)} #if weight is a single value, use as number of entities
dummy <- data.table(weight) #convert weights to data table format, if necessary.
if(length(filter)>0 & "group"%in%colnames(dummy)) {dummy <- dummy[group==filter,]} #filter if appropriate
if(is.null(breaks)==TRUE) {breaks <- seq(start.date, end.date, bin.width)} #if breaks not specified, sets them based on other arguments
View(weight)
for(i in 1:(length(breaks)-1)) {
labels[i] <- paste(breaks[i], breaks[i+1], sep="-") #sets bin labels based on breaks
}
probs <- data.table(cbind(probs, labels)) #append labels to relative probs, recycling the latter if necessary
rep.no <- rep(1:reps, each=nrow(dummy))
dummy <- cbind(rep.no, dummy) #recycles input data 'reps' times to provide frame for simulation
p.sum <- sum(as.numeric(probs$probs)) #'stacks up' all the relative probabilities
p.breaks <- c(0, cumsum(as.numeric(probs$probs))) #uses cumulative sum of relative probabilities to set breaks
dummy[,sim:=runif(nrow(dummy), 0, p.sum)] #samples from within p.sum
dummy[,bin.no:=cut(sim, p.breaks, labels=FALSE)] #records the relevant bin for each simulated date
dummy[,bin:=cut(sim, p.breaks, labels=probs$labels)] #finds the relevant bin labels
dummy <- dummy[is.na(bin)==FALSE, j=list(count=sum(weight)), by=list(rep.no,bin,bin.no)] #sums weights by bin and rep number
View(dummy)
setnames(weight, 1,"weight")
View(weight)
dummy <- data.table(weight) #convert weights to data table format, if necessary.
if(length(filter)>0 & "group"%in%colnames(dummy)) {dummy <- dummy[group==filter,]} #filter if appropriate
if(is.null(breaks)==TRUE) {breaks <- seq(start.date, end.date, bin.width)} #if breaks not specified, sets them based on other arguments
for(i in 1:(length(breaks)-1)) {
labels[i] <- paste(breaks[i], breaks[i+1], sep="-") #sets bin labels based on breaks
}
probs <- data.table(cbind(probs, labels)) #append labels to relative probs, recycling the latter if necessary
rep.no <- rep(1:reps, each=nrow(dummy))
dummy <- cbind(rep.no, dummy) #recycles input data 'reps' times to provide frame for simulation
p.sum <- sum(as.numeric(probs$probs)) #'stacks up' all the relative probabilities
p.breaks <- c(0, cumsum(as.numeric(probs$probs))) #uses cumulative sum of relative probabilities to set breaks
dummy[,sim:=runif(nrow(dummy), 0, p.sum)] #samples from within p.sum
dummy[,bin.no:=cut(sim, p.breaks, labels=FALSE)] #records the relevant bin for each simulated date
dummy[,bin:=cut(sim, p.breaks, labels=probs$labels)] #finds the relevant bin labels
View(dummy)
dummy <- dummy[is.na(bin)==FALSE, j=list(count=sum(weight)), by=list(rep.no,bin,bin.no)] #sums weights by bin and rep number
class(weight$weight)
class(weight$weight) <- numeric
dummy <- dummy[is.na(bin)==FALSE, j=list(count=sum(as.numeric(weight))), by=list(rep.no,bin,bin.no)] #sums weights by bin and rep number
dummy[order(rep.no, bin.no)]
dummy.simulate <- function(weight, probs=1, breaks=NULL, filter=NULL, start.date=0, end.date=2000, bin.width=100, reps=100) {
require(data.table)
if(is.vector(weight)==1 & length(weight)==1) {weight <- rep(1, weight)} #if weight is a single value, use as number of entities
dummy <- data.table(weight) #convert weights to data table format, if necessary.
if(length(filter)>0 & "group"%in%colnames(dummy)) {dummy <- dummy[group==filter,]} #filter if appropriate
if(is.null(breaks)==TRUE) {breaks <- seq(start.date, end.date, bin.width)} #if breaks not specified, sets them based on other arguments
for(i in 1:(length(breaks)-1)) {
labels[i] <- paste(breaks[i], breaks[i+1], sep="-") #sets bin labels based on breaks
}
probs <- data.table(cbind(probs, labels)) #append labels to relative probs, recycling the latter if necessary
rep.no <- rep(1:reps, each=nrow(dummy))
dummy <- cbind(rep.no, dummy) #recycles input data 'reps' times to provide frame for simulation
p.sum <- sum(as.numeric(probs$probs)) #'stacks up' all the relative probabilities
p.breaks <- c(0, cumsum(as.numeric(probs$probs))) #uses cumulative sum of relative probabilities to set breaks
dummy[,sim:=runif(nrow(dummy), 0, p.sum)] #samples from within p.sum
dummy[,bin.no:=cut(sim, p.breaks, labels=FALSE)] #records the relevant bin for each simulated date
dummy[,bin:=cut(sim, p.breaks, labels=probs$labels)] #finds the relevant bin labels
dummy <- dummy[is.na(bin)==FALSE, j=list(count=sum(as.numeric(weight))), by=list(rep.no,bin,bin.no)] #sums weights by bin and rep number
dummy[order(rep.no, bin.no)]
}
class(weight$weight)
dummy.simulate(y)
View(y)
library(archSeries)
library(devtools)
install.packages(data.table)
install.packages("data.table")
install.packages("devtools")
library(devtools)
install.packages("devtools")
install.packages("curl1.dev")
install.packages("devtools")
install.packages("RCurl")
install.packages("devtools")
install.packages("data.table")
install.packages("devtools")
install.packages("xml2")
# Load required packages
library(data.table)
library(devtools)
install_github("davidcorton/archSeries")
library(archSeries)
# Load required packages
library(data.table)
library(devtools)
install_github("davidcorton/archSeries")
library(archSeries)
# Load required packages
library(data.table)
library(devtools)
install_github("davidcorton/archSeries")
library(archSeries)
# Read in data
period <- data.table(read.csv("period-CLEANED.csv"))
setkey(period, SITE_P)
context <- data.table(read.csv("context-RAW.csv"))
setkey(context, SITE_C)
sample <- data.table(read.csv("sample-CLEANED.csv"))
setkey(sample, SITE_S)
zoo <- data.table(read.csv("zoo-CLEANED.csv"))
setkey(zoo, SITE_C)
species <- data.table(read.csv("species_codes.csv"))
landuse <- data.table(read.csv("landuse_codes.csv"))
interpretation <- data.table(read.csv("int_codes.csv"))
# Merge species information and select fish
zoo <- merge(zoo, species, by="SPECIES", all.x=TRUE, all.y=FALSE)
fish <- zoo[CLASS=="fish"]
other.classes <- zoo[CLASS%in%c("mammal", "bird", "amphib", "reptile")]
# Merge context information
context.period <- merge(period[,list(SITE_P,Start,End)], context[,list(SITE_C,SITE_P,BASIC_INT,LU_INT)], by="SITE_P", all=FALSE)
fish.period <- merge(fish[!SAMPLE==0], context.period, by="SITE_C", all=FALSE)
other.period <- merge(other.classes[!SAMPLE==0], context.period, by="SITE_C", all=FALSE)
sample.period <- merge(sample, context.period, by="SITE_C", all=FALSE)
sample.period <- merge(sample.period, landuse, by="LU_INT", all.x=TRUE, all.y=FALSE)
sample.period <- merge(sample.period, interpretation, by="BASIC_INT", all.x=TRUE, all.y=FALSE)
rm(context, period, context.period, sample, fish, species)
setwd("~/Dropbox/London repo")
# Read in data
period <- data.table(read.csv("period-CLEANED.csv"))
setkey(period, SITE_P)
context <- data.table(read.csv("context-RAW.csv"))
setkey(context, SITE_C)
sample <- data.table(read.csv("sample-CLEANED.csv"))
setkey(sample, SITE_S)
zoo <- data.table(read.csv("zoo-CLEANED.csv"))
setkey(zoo, SITE_C)
species <- data.table(read.csv("species_codes.csv"))
landuse <- data.table(read.csv("landuse_codes.csv"))
interpretation <- data.table(read.csv("int_codes.csv"))
# Merge species information and select fish
zoo <- merge(zoo, species, by="SPECIES", all.x=TRUE, all.y=FALSE)
fish <- zoo[CLASS=="fish"]
other.classes <- zoo[CLASS%in%c("mammal", "bird", "amphib", "reptile")]
# Merge context information
context.period <- merge(period[,list(SITE_P,Start,End)], context[,list(SITE_C,SITE_P,BASIC_INT,LU_INT)], by="SITE_P", all=FALSE)
fish.period <- merge(fish[!SAMPLE==0], context.period, by="SITE_C", all=FALSE)
other.period <- merge(other.classes[!SAMPLE==0], context.period, by="SITE_C", all=FALSE)
sample.period <- merge(sample, context.period, by="SITE_C", all=FALSE)
sample.period <- merge(sample.period, landuse, by="LU_INT", all.x=TRUE, all.y=FALSE)
sample.period <- merge(sample.period, interpretation, by="BASIC_INT", all.x=TRUE, all.y=FALSE)
rm(context, period, context.period, sample, fish, species)
fish.sim <- freq.simulate(fish.period, weight=fish.period$FRAG_COUNT, bin.width=50, reps=2000)
x <- date.simulate(fish.period)
x <- dummy.simulate(fish.period)
aorist(fish.period)
library(roxygen2)
document()
setwd("~/Dropbox/archSeries")
document()
document()
